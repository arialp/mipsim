# mipsim - A MIPS Processor Simulator

## Project Objective
To simulate a subset of the MIPS 32-bit architecture, enabling users to write, assemble, and execute MIPS assembly code in a simulated environment.

## Design Methodology
The design and implementation of mipsim were carried out in several systematic phases:

### 1. Assembler Implementation
To convert textual MIPS assembly code into binary machine code:

- Register Names and Instructions Mapping:
  - A HashMap was used for register names ($zero, $at, etc.).
  - Supported instruction opcodes (e.g., add, sub, lw) and function codes for R-type instructions were also mapped in HashMap objects.

- Multi-Pass Assembler:
  - The assembler processes the input in three passes:
    - Handle comments and clean assembly lines.
    - Parse labels and associate them with memory addresses.
    - Convert instructions to binary, taking into account the opcode, register mappings, and immediate values.

### 2. Instruction and Data Memory
- Memory Design:
  - Instruction and data memory are designed to follow MIPS architecture:
    - Addresses are 4-byte aligned.
    - Memory addressing ensures a difference of 4 between consecutive memory addresses.
  - Instruction Memory:
    - Stores binary instructions generated by the assembler.
    - Provides methods to retrieve instructions by address.
  - Data Memory:
    - Stores 32-bit values at specific memory locations.
    - Allows for both read (load) and write (store) operations.
   
### 3. Register File
- Implements the 32 general-purpose registers of MIPS architecture.
- $zero register is read-only and always contains the value 0.
- Special registers include $sp (stack pointer) and $ra (return address).
- Provides methods to read and write register values and retrieve the current register states.

### 4. Graphical User Interface (GUI)
- A preliminary GUI was created to test and verify the assembler:
  - Users can input assembly code, view machine code, and inspect memory and register states.
  - Buttons for toggling between binary and hexadecimal views.
- Later enhanced to integrate simulator functionality:
  - Controls: Assemble, run, step through, and reset.
  - Visual Components:
    - Text areas for assembly input, machine code output, instruction memory, data memory, and register files.
    - Highlight the program counter (PC) during simulation.

### 5. Simulator
The core of mipsim, responsible for executing machine code:

- Initialization:
  - Loads assembled machine code into instruction memory.
  - Initializes data memory and register file, setting $sp to 0xFFFFFFFF.
- Fetch-Decode-Execute Cycle:
  - Fetch: Retrieves the instruction at the current PC.
  - Decode: Parses the instruction into opcode, register indices, immediate values, or target addresses.
  - Execute: Executes the instruction based on its type (R, I, or J). Supports:
    - Arithmetic (add, sub, etc.).
    - Logical operations (and, or).
    - Memory operations (lw, sw).
    - Branching (beq, bne, j, jal, jr).
- PC Management:
  - Automatically increments the PC unless modified by a branch or jump.
- Reset:
  - Resets the program counter, register file, and memory to their initial states.

### 6. Testing and Debugging
- Assembler functionality was tested using the GUI before integrating with the simulator.
- Debugging was aided by console outputs during invalid opcode or memory accesses.

### Features
- Assembly Code Support:
  - Recognizes a subset of MIPS instructions (R, I, and J formats).
- Memory Management:
  - Ensures MIPS-compatible memory alignment and addressing.
- Real-Time Simulation:
  - Step-by-step execution of instructions with state updates in GUI.
- Visual Feedback:
  - Displays binary/hexadecimal machine code and highlights PC during execution.
- Reset Functionality:
  - Allows users to restart the simulation without reloading the program.
